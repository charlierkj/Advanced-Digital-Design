module byte_rotation (input logic clk, reset_n, start,
                      input logic [15:0] message_addr, size, output_addr,
							 output logic done, mem_clk, mem_we, 
							 output logic [15:0] mem_addr,
							 output logic [31:0] mem_write_data,
							 input logic [31:0] mem_read_data);
  enum logic [1:0] {IDLE=2'b00, OPERATE=2'b01, DONE=2'b1} state;
  
  function logic byte_rotate (input logic [31:0] value);
      byte_rotate = {value[23:16], value[15:8], value[7:0], value[31:24]};
  endfunction
  
  logic [15:0] count;
 
  assign mem_clk=clk;
  
  always_ff @(posedge clk, negedge reset_n)
  begin
    if (!reset_n) begin
	   state <= IDLE;
	   done <= 0;
	 end else
		case (state)
		  IDLE:
		    if (start) begin
			   count <= size;
			   state <= OPERATE;
				mem_we <= 0;
				mem_addr <= message_addr;
			 end
		  OPERATE:
		    if (count>1) begin
			   count <= count - 1;
				mem_read_data <= byte_rotate(mem_read_data);
				mem_we <= 1;
				mem_addr <= output_addr-message_adr+mem_addr;
				mem_we <= 0;
				mem_addr <= message_addr+size-count;
			  end else begin
			   state <= DONE;
				done <= 1;
			  end
			DONE:
			  state <= IDLE;
		  endcase
		 end
endmodule			 
			   